pipeline {
    agent any

	triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            steps {
                git url: 'https://github.com/finnxthomas/OurClass-API.git',
                    branch: 'main',
                    credentialsId: 'github-token'
            }
        }

        stage('Install Requirements') {
            steps {
                sh 'pip3 install -r requirements.txt --break-system-packages'
            }
        }

		stage ('Run Pytest Suite to Test Class-API Functionality')
		{
			steps {
				echo "--- RUNNING PYTEST SUITE ---"
                sh 'chmod +x test_class_api.sh'  // Make test.sh executable
                sh './test_class_api.sh'
            }

		}

        stage('Launch API + Run Jmeter Load Tests') {
            steps {
				script
				{
					echo "--- 1. STARTING FASTAPI SERVER ---"
					// Start API in background using uvicorn
					//		- 'nohup /var/jenkins_home/.local/bin/uvicorn class_api:app' | Starts class_api.py's app (The FASTAPI). It runs continuously in the background
					//		- '--host 0.0.0.0 --port 8000' | Makes the API available externally on port 8000
					// 		- '> api.log 2>&1 &' | Redirect standard output (stdout) to api.log, redirect standard error (stderr) to standard output
					sh 'nohup /var/jenkins_home/.local/bin/uvicorn api.class_api:app --host 0.0.0.0 --port 8000 > api.log 2>&1 &'
					
					echo "--- 2. WAITING FOR API TO BOOT ---"
					sleep 5

					echo "--- 3. RUNNING JMETER LOAD TEST ---"
					sh 'rm -rf dashboard_realistic dashboard_crash realistic.jtl crash.jtl api.log *.zip' // Clean up files from last build
					// Run Jmeter load balancing tests
					// 		- '/opt/apache-jmeter-5.6.3/bin/jmeter -n' |  Run jmeter from location in Jenkins in Non GUI mode (necessary for Jenkins)
					// 		- '-t jmeter/load_test.jmx' | Run the specificed test plan
					// 		- '-l results.jtl'. | Output the results in results.jtl
					// 		- '-e -o dashboard' | Generate an HTML dashboard of results when finished
					// 		- '-Jusers=30' | Run the test simulated 30 virtual users of the API
					// 		- 'Jsecure.ignore_xstream_security=true' | JMeter property, enabling a compatibility/security override.

					echo "--- RUNNING REALISTIC CLASS TEST (30 Users) ---"
                    sh '/opt/apache-jmeter-5.6.3/bin/jmeter -n -t jmeter/load_test.jmx -l realistic.jtl -e -o dashboard_realistic -Jusers=30 -Jrampup=5 -Jduration=30 -Jsecure.ignore_xstream_security=true'
                    
                    echo "--- RUNNING RAMP-UP CAPACITY TEST (Goal: 5000 Users) ---"
                    sh '/opt/apache-jmeter-5.6.3/bin/jmeter -n -t jmeter/load_test.jmx -l crash.jtl -e -o dashboard_crash -Jusers=5000 -Jrampup=100 -Jduration=120 -Jsecure.ignore_xstream_security=true'

					echo "--- 4. TESTS FINISHED, CLEANING UP ---"
					sh "pkill -f 'uvicorn api.class_api:app'"
				}
            }
        }
    }


	post {
		success {
			script { 
				sh 'zip -r realistic_report.zip dashboard_realistic || true'
                sh 'zip -r crash_report.zip dashboard_crash || true'

				archiveArtifacts artifacts: '*.zip', allowEmptyArchive: true
                archiveArtifacts artifacts: '*.jtl', allowEmptyArchive: true
                archiveArtifacts artifacts: 'api.log', allowEmptyArchive: true

				def realisticLink = "${env.BUILD_URL}artifact/realistic_report.zip"
				def crashLink = "${env.BUILD_URL}artifact/crash_report.zip"
				def buildLink = "${env.BUILD_URL}"

				def message = """\
---

#### Build ${env.BUILD_NUMBER} in ${env.JOB_NAME} was SUCCESSFUL

View here: [Build ${env.BUILD_NUMBER}](${buildLink})

ðŸ“Š Load Tests are Complete! Download the Reports here:

1. Baseline Test (30 Users): [Download Report](${realisticLink})

2. Capacity Test (5000 Users): [Download Report](${crashLink})

---

""".stripIndent()
				notifyWebex(message)

				
			}
		}
		failure {
			script{ 
				def message = """\
---

#### Build ${env.BUILD_NUMBER} in ${env.JOB_NAME} has FAILED

View here: <${env.BUILD_URL}|open>

ðŸ“Š Load Test was not complete.

---
""".stripIndent()
				notifyWebex(message)
			}
		}
	}
}

/**
 * Sends a markdown message to a Webex room using a BOT token.
 * Requires credentials:
 *   - WEBEX_BOT_TOKEN (Secret text)
 *   - WEBEX_ROOM_ID   (Secret text or String)
 */
def notifyWebex(String msg) {
  withCredentials([
    string(credentialsId: 'CLASS_API_BOT_TOKEN', variable: 'WB_TOKEN'),
    string(credentialsId: 'CLASS_API_ROOM_ID',  variable: 'ROOM_ID')
  ]) {
    def body = groovy.json.JsonOutput.toJson([ roomId: ROOM_ID, markdown: msg ])
    try {
      httpRequest(
        httpMode: 'POST',
        url: 'https://webexapis.com/v1/messages',
        customHeaders: [[name: 'Authorization', value: "Bearer ${WB_TOKEN}"]],
        contentType: 'APPLICATION_JSON',
        requestBody: body,
        validResponseCodes: '200:299'
      )
    } catch (err) {
      echo "Webex notify failed: ${err}"
    }
  }
}